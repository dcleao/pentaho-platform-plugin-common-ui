/*!
 * Copyright 2010 - 2015 Pentaho Corporation.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
define([
  "../../i18n!types",
   "../../lang/Base",
   "../../lang/_AnnotatableLinked",
   "../../util/error",
   "../../util/fun",
   "../../util/object",
   "../../util/promise"
], function(bundle, Base, AnnotatableLinked, error, fun, O, promise) {

  "use strict";

  var baseMid = "pentaho/type/";

  // Default type, in a type specification.
  var defaultTypeMid = "string";

  // Default `base` type in a type specification.
  var defaultBaseTypeMid = "complex";

  // Unique type class id exposed through Type.prototype.uid and
  // used by Context instances.
  var _nextUid = 1;

  // Standard types which can be assumed to already be loaded.
  var basicStandardTypes = {};
  ["value", "complex", "simple", "string", "number", "boolean", "date"].forEach(function(name) {
    basicStandardTypes[baseMid + name] = 1;
  });

  var configurableProps = {
      "label": 1,
      "labelPlural": 1,
      "description": 1,
      "category": 1,
      "helpUrl": 1,
      "styleClass": 1,
      "value": 1,
      "format": 1
    };

  /**
   * @name pentaho.type.Value
   * @class
   * @abstract
   *
   * @classDesc
   *
   * The static class interface implements {@link pentaho.lang.IConfigurable}.
   *
   * A type class is a _singleton_ class.
   * Its sole instance is accessible through property {@link pentaho.type.Value.the}.
   *
   * Example value type:
   * ```javascript
   * define(["pentaho/type/value"], function(ValueType) {
   *   return ValueType.extend({
   *     // Defaults
   *
   *     // Name of a single element of this type of value.
   *     name: "name",
   *
   *     // Label of a single element of this type of value.
   *     label: "Name",
   *
   *     // Plural label of elements of this type of value.
   *     labelPlural: "Names",
   *
   *     // Category of the type of value or concept
   *     category: "foo",
   *
   *     // Description of the type of value
   *     description: "Foo",
   *
   *     helpUrl: "foo/bar"
   *
   *     value: null,
   *
   *     // min, max - for _ordered_ types (number, string, any having compare specified?)
   *     // minOpen, maxOpen? false
   *     // lengthMin, lengthMax, pattern - facets for strings only
   *
   *     // Arbitrary metadata
   *     p: {
   *     },
   *
   *     // Closed domain of _values_ of this type.
   *     // When inherited, specified values must be a subset of those in the base class.
   *     // By default, the list is an undetermined, possibly infinite,
   *     // set of all values allowed in the base domain...
   *     // This also specifies the default natural ordering of the values.
   *     domain: [],
   *
   *     // Default formatting specification for values of this type
   *     format: {},
   *
   *     styleClass: ""
   *   });
   * });
   * ```
   *
   * @description Creates a type instance.
   */
  var Value = Base.extend("pentaho.type.Value", /** @lends pentaho.type.Value# */{

    constructor: function() {
      // NOTE: block default Base.js copy arg to this
    },

    // Implementation note:
    //  The following JS properties are used to set properties on the class' prototypes,
    //  upon calls to Class.extend and Class.configure,
    //  through the properties' setters.
    //
    //  Generally, type instances are immutable and are not changeable.
    //
    //  The user should not use the setters on actual `Type` instances...

    //region uid property
    _uid: _nextUid++,

    /**
     * Gets the unique type id.
     *
     * The unique type id is autogenerated when creating a new class through {@link pentaho.type.Value.extend}.
     * All instances of the type have the same unique id.
     *
     * Note that anonymous types do not have a {@link pentaho.type.Value#id}.
     * However, all types an unique id.
     *
     * This property is (obviously) not inherited.
     *
     * @type number
     * @readonly
     */
    get uid() {
      return this._uid;
    },
    //endregion

    //region ancestor property
    /**
     * Gets the ancestor (singleton) type instance, if any, or `null`.
     * @type pentaho.type.Value
     */
    get ancestor() {
      return this !== Value.prototype ? this.constructor.ancestor.the : null;
    },
    //endregion

    //region id property

    // -> nonEmptyString, Optional(null), Immutable, Shared (note: not Inherited)
    // "" -> null conversion

    _id: baseMid + "value",

    /**
     * Gets the id of the value type.
     *
     * Can only be specified when extending a type.
     *
     * Only types which have an associated AMD/RequireJS module have an id.
     * However, all types a {@link pentaho.type.Value#uid}.
     *
     * This property is not inherited.
     *
     * @type ?nonEmptystring
     */
    get id() {
      return this._id;
    },
    //endregion

    //region label property
    // @type !nonEmptyString
    // -> nonEmptyString, Optional, Inherited, Configurable, Localized
    // null or "" -> undefined conversion

    _label: null, // set through configure, below

    get label() {
      return this._label;
    },

    set label(value) {
      // null or "" -> undefined conversion
      if(value == null || value === "") {
        if(this !== Value.prototype) {
          delete this._label;
        }
        // else ignore... nowhere to inherit from
      } else {
        this._label = value;
        if(!this.hasOwnProperty("_labelPlural")) {
          this._labelPlural = value + "s";
        }
      }
    },
    //endregion

    //region labelPlural property

    // @type !nonEmptyString
    // -> nonEmptyString, Optional, Inherited, Configurable, Localized
    // null or "" -> undefined conversion
    // Defaulted from `label`, when set locally, or inherited from base `labelPlural`.

    _labelPlural: null, // set through configure, below

    get labelPlural() {
      return this._labelPlural;
    },

    set labelPlural(value) {
      if(!value) {
        if(this !== Value.prototype) {
          delete this._labelPlural;
        }
      } else {
        this._labelPlural = value;
      }
    },
    //endregion

    //region description property

    // -> nonEmptyString, Optional, Inherited, Configurable, Localized
    // "" -> null conversion

    _description: null, // set through configure, below

    get description() {
      return this._description;
    },

    set description(value) {
      if(value === undefined) {
        delete this._description;
      } else {
        this._description = value || null;
      }
    },
    //endregion

    //region category property

    // -> nonEmptyString, Optional, Inherited, Configurable, Localized
    // "" -> null conversion

    _category: null,

    get category() {
      return this._category;
    },

    set category(value) {
      if(value === undefined) {
        delete this._category;
      } else {
        this._category = value || null;
      }
    },
    //endregion

    //region helpUrl property

    // -> nonEmptyString, Optional, Inherited, Configurable, Localized?
    // "" -> null conversion

    _helpUrl: null,

    get helpUrl() {
      return this._helpUrl;
    },

    set helpUrl(value) {
      if(value === undefined) {
        delete this._helpUrl;
      } else {
        this._helpUrl = value || null;
      }
    },
    //endregion

    //region styleClass property
    // @type nonEmptyString
    // -> nonEmptyString, Optional(null), Configurable, Localized
    // "" or undefined -> null conversion

    _styleClass: null,

    get styleClass() {
      return this._styleClass;
    },

    set styleClass(value) {
      // undefined or "" -> null conversion
      this._styleClass = value || null;
    },
    //endregion

    //region format

    // TODO: recursively inherit? clone? merge on set?

    // -> Optional({}), Inherited, Configurable
    _format: undefined,

    get format() {
      return this._format;
    },

    set format(value) {
      if(value === undefined) {
        // Reset
        if(this !== Value.prototype)
          delete this._format;
        else
          this._format = {};
      } else {
        this._format = value || {};
      }
    },
    //endregion

    //region domain

    // Closed domain of _values_ of this type.
    // Also defines the default natural ordering of the values.
    // When inherited, specified values must be a subset of those in the base class.
    // Although they can be in a different order.
    // By default, the list is an undetermined, possibly infinite,
    // set of all values allowed in the base domain...
    // Because it is not possible to escape a base domain,
    // both setting to undefined or null resets the property,
    // inheriting the base domain.
    _domain: null,

    get domain() {
      return this._domain;
    },

    set domain(value) {
      var baseDomain = Object.getPrototypeOf(this)._domain;
      if(value == null) {
        // inherit unless we're the root
        if(baseDomain !== undefined)
          delete this._domain;
        else
          this._domain = null;
      } else {
        if(baseDomain && !isSubsetOf(value, baseDomain))
          throw error.argInvalid("domain", bundle.structured.errors.type.domainIsNotSubsetOfBase);

        this._domain = value;
      }
    },
    //endregion

    //region IConfigurable implementation
    /**
     * Configures a type _class_.
     *
     * This method _must not_ be called directly on type instances.
     * It is expected to be called on the `prototype` of
     * the constructor function, to configure the class.
     *
     * @param {!pentaho.type.spec.ITypeConfig} config A type class configuration.
     * @protected
     * @see pentaho.type.Value.configure
     */
    _configure: function(config) {
      this._configureLocal(config);
    },

    /**
     * Configures the local part of a type class.
     *
     * This method _must not_ be called directly on type instances.
     * It is expected to be called on the `prototype` of
     * the constructor function, to configure the class.
     *
     * Complex types have a "non-local part", constituted by their properties.
     * This method exposes only "local" configurations.
     *
     * This method can be overridden by sub-classes to handle
     * additional local configurations.
     *
     * @param {!pentaho.type.spec.ITypeConfig} config A type instance configuration.
     * @protected
     * @see pentaho.type.Value.configure
     */
    _configureLocal: function(config) {
      if(!config) throw error.argRequired("config");

      // undefined passes through.
      // Semantics is imposed by each setter.
      for(var p in config)
        if(configurableProps[p] === 1)
          this[p] = config[p];

      AnnotatableLinked.configure(this, config);
    },
    //endregion

    // All empty values should have key=""
    isEmpty: function(value) {
      return value === null;
    },

    getKey: function(value) {
      // A unique key of the value among values of the same "kind".
      // TODO: Specifically, unique among values of its first sub-class???
      return this.isEmpty(value) ? "" : String(value);
    },

    // Unit validation of a value.
    // Returns array of non-empty Error objects or null
    validate: function(value) {
      return this.isEmpty(value) ? null : this.validateNonEmpty(value);
    },

    // Should be consistent with result of compare.
    // areEqual => compare -> 0
    areEqual: function(va, vb) {
      return va === vb ||
        (this.isEmpty(va) && this.isEmpty(vb)) ||
        this.areEqualNonEmpty(va, vb);
    },

    areEqualNonEmpty: function(va, vb) {
      return va === vb;
    },

    // consistent with isEmpty and areEqual
    compare: function(va, vb) {
      // Quick bailout test
      if(va === vb) return 0;

      if(this.isEmpty(va)) return this.isEmpty(vb) ? 0 : 1;
      if(this.isEmpty(vb)) return -1;
      if(this.areEqualNonEmpty(va, vb)) return 0;
      return this.compareNonEqualOrEmpty(va, vb);
    },

    // Validation of a non-empty value.
    // Should call the base method first.
    // TODO: Only undefined and arrays are not possible values?
    validateNonEmpty: function(value) {
      return value === undefined    ? [new Error(bundle.structured.errors.value.isUndefined)] :
             value instanceof Array ? [new Error(bundle.structured.errors.value.singleValueIsArray)] :
             null;
    },

    // natural ascending comparer of non-equal, non-empty values
    compareNonEqualOrEmpty: function(va, vb) {
      return fun.compare(va, vb);
    },

    // TODO: Serialization of a Specification to/from JSON
    toJSON: function(value) {
    },

    fromJSON: function(json) {
    }
  }, /** @lends pentaho.type.Value */{

    // Overrides documentation only.
    /**
     * Creates a subclass of this value type class.
     *
     * @name pentaho.type.Value.extend
     *
     * @param {string} [name] The name of the value type sub-class.
     * @param {pentaho.type.spec.IType} instSpec The value type extend specification.
     * @param {Object} [classSpec] Class-level members of the value type class.
     *
     * @return {Class.<pentaho.type.Value>} The created value type sub-class.
     */

    // @override
    _extend: function(name, instSpec) {
      if(!instSpec) instSpec = {};

      var id = consumeProp(instSpec, "id");

      var Derived = this.base.apply(this, arguments);

      // -----
      // Shared, Immutable, Non-inheritable
      var derived = Derived.prototype;
      derived._id  = id || null;
      derived._uid = _nextUid++;

      // Block inheritance
      if(!("styleClass" in instSpec)) derived._styleClass = null;

      return Derived;
    },

    //region the property
    /**
     * Gets the single type instance.
     * @type pentaho.type.Value
     */
    get the() {
      //noinspection JSValidateTypes
      return this.prototype;
    },
    //endregion

    //region IConfigurable _class_ implementation
    /**
     * Configures a type _class_.
     *
     * @param {!pentaho.type.spec.ITypeConfig} config A type class configuration.
     * @return {Class.<pentaho.type.Value>} The class.
     *
     * @see pentaho.type.Value#_configure
     * @see pentaho.type.Value#_configureLocal
     */
    configure: function(config) {
      this.prototype._configure(config);
      //noinspection JSValidateTypes
      return this;
    },
    //endregion

    resolveAsync: function(typeSpec) {
      return resolve(typeSpec, true);
    },

    resolve: function(typeSpec) {
      return resolve(typeSpec, false);
    }
  })
  .implement(AnnotatableLinked)
  .configure(bundle.structured.value);

  return Value;

  function resolve(typeSpec, async) {
    // Default property type is "string".
    if(!typeSpec) typeSpec = defaultTypeMid;

    switch(typeof typeSpec) {
      case "string":
        // It's considered an AMD id only if it has at least one "/".
        // Otherwise, append pentaho's base amd id.
        if(typeSpec.indexOf("/") < 0) {
          typeSpec = baseMid + typeSpec;
        }

        // This fails if a module with the id in the `typeSpec` var
        // is not already _loaded_.
        return async ? promise.require([typeSpec]) : require(typeSpec);

      case "function":
        // Is it a ValueType class?
        if(!(typeSpec.prototype instanceof Value)) {
          throw error.argInvalid(
            "typeSpec",
            bundle.structured.errors.typeSpec.isInvalidFun);
        }

        return async ? Promise.resolve(typeSpec) : typeSpec;

      case "object":
        // Properties only: [string||{}, ...] or
        // Inline type spec: {[base: "complex", ] ... }
        if(typeSpec instanceof Array) typeSpec = {props: typeSpec};

        var baseTypeSpec = typeSpec.base || defaultBaseTypeMid,
            resolveSync = function() {
              return resolve(baseTypeSpec, false).extend(typeSpec);
            };

        if(!async) return resolveSync();

        // Collect the module ids of all custom types used within typeSpec.
        var customTypeIds = [];
        collectTypeIds(typeSpec, customTypeIds);

        // Require them all and only then invoke the synchronous BaseType.extend method.
        if(customTypeIds.length)
          return promise.require(customTypeIds).then(resolveSync);

        // All types are standard and can be assumed to be already loaded.
        // Anyway, must only extend async...
        return new Promise(function(resolve) { resolve(resolveSync()); });
    }

    throw error.argInvalid("typeSpec");
  }

  // Recursively collect the module ids of all custom types used within typeSpec.
  function collectTypeIds(typeSpec, outIds) {
    if(!typeSpec) return;

    switch(typeof typeSpec) {
      case "string":
        // It's considered an AMD id only if it has at least one "/".
        // Otherwise, append pentaho's base amd id.
        if(typeSpec.indexOf("/") < 0) typeSpec = baseMid + typeSpec;

        // A standard type that is surely loaded?
        if(basicStandardTypes[typeSpec] === 1) return;

        outIds.push(typeSpec);
        return;

      case "object":
        // Properties only: [string||{}, ...] or
        // Inline type spec: {[base: "complex", ] ... }
        if(typeSpec instanceof Array) typeSpec = {props: typeSpec};

        collectTypeIds(typeSpec.base, outIds);

        if(typeSpec.props) typeSpec.props.forEach(function(propSpec) {
          collectTypeIds(propSpec && propSpec.type, outIds);
        });
        return;
    }
  }

  function consumeProp(o, p) {
    var v;
    if(o && (p in o)) {
      v = o[p];
      delete o[p];
    }
    return v;
  }

  function isSubsetOf(sub, sup, key) {
    if(!key) key = fun.identity;

    var L1 = sup.length, L2 = sub.length, i, supIndex;
    if(L2 > L1) return false;

    supIndex = {};
    i = L1;
    while(i--) supIndex[key(sup[i])] = 1;

    i = L2;
    while(i--) if(!O.hasOwn(supIndex, key(sub[i]))) return false;

    return true;
  }
});
